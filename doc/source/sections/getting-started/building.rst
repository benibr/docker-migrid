Building
========

To build the Docker version of MiGrid, the repository provides a Makefile that helps you out.

Overview
-----------

Before you can build an image, you need to select which MiGrid services you would like to run.
This choice will lead you to select or configure an environment file that suit your particular choice.
There are different predefined environments available in this repository (eg. `development.env` or `advanced.env`).

After choosing an environment and adapting it to your needs, you can enable it by creating an .env symlink that points to your particular environment configuration.
For instance, if you want to build the MiGrid image with the default environment settings, this is achived by the Makefile init target, which will automatically create a symlink from development.env to the expected .env file. If this behaviour is not wanted, a symlink has to be manually created before make is called to link the designated environment file to the .env file. For instance::

    ln -s my-custom-environment.env .env

Be aware that `.env` itself is excluded from the git repository via `.gitignore`.

Quick Start
-----------

If you are not interested in learning what goes into building the image, the easiest way to get started, is to simply run `make` inside the `docker-migrid` directory::

    make

This should produces the following output::

    rm -rf ./certs
    rm -rf ./httpd
    rm -rf ./mig
    rm -rf ./state
    if [ "$(docker volume ls -q -f 'name=docker-migrid*')" != "" ]; then\
            docker volume rm -f $(docker volume ls -q -f 'name=docker-migrid*');\
        fi
    mkdir -p certs
    mkdir -p httpd
    mkdir -p mig
    mkdir -p state
    docker-compose build
    WARNING: Python-dotenv could not parse statement starting at line 5
    devdns uses an image, skipping
    nginx-proxy uses an image, skipping
    Building migrid
    [+] Building 38.6s (13/75)
    ...

In addition to the above output, several build lines should follow as the Docker container image is being build.
The entire process should be succesfully completed, when the following lines have been printed::


     => => naming to docker.io/ucphhpc/migrid:basic                                         0.0s


Additional Details
------------------

When building the Docker MiGrid container image, several things are being done in addition to just producing the target `docker-migrid` image.
An indication of this can be seen by investigating the `Makefile` itself::

    :docker-migrid username$cat Makefile
    NAME=docker-migrid
    OWNER=ucphhpc
    IMAGE=migrid
    # Enable that the builder should use buildkit
    # https://docs.docker.com/develop/develop-images/build_enhancements/
    DOCKER_BUILDKIT=1

    .PHONY:	all init build clean reset push

    all: clean init build

    init:
        mkdir -p certs
        mkdir -p httpd
        mkdir -p mig
        mkdir -p state

    build:
        docker-compose build ${ARGS}

    clean:
        rm -rf ./certs
        rm -rf ./httpd
        rm -rf ./mig
        rm -rf ./state
        if [ "$$(docker volume ls -q -f 'name=${NAME}*')" != "" ]; then\
            docker volume rm -f $$(docker volume ls -q -f 'name=${NAME}*');\
        fi

    dockerclean:
        docker image prune -f
        docker container prune -f
        docker volume prune -f

    reset:
        rm -rf ./certs
        rm -rf ./httpd
        rm -rf ./state
        if [ "$$(docker volume ls -q -f 'name=${NAME}*')" != "" ]; then\
            docker volume rm -f $$(docker volume ls -q -f 'name=${NAME}*');\
        fi

    push:
        docker push ${OWNER}/${IMAGE}

For starters, when `make` is being executed within the directory. The directory is firstly being cleaned of any old state data that might be hanging around from the last build.
This is achived by executing the `clean` target within the `Makefile`. The `clean` target removes the runtime directories and all of the associated docker volumes that is used to store persistent data between runtimes::


    :docker-migrid username$ make clean
    rm -rf ./certs
    rm -rf ./httpd
    rm -rf ./mig
    rm -rf ./state
    if [ "$(docker volume ls -q -f 'name=docker-migrid*')" != "" ]; then\
            docker volume rm -f $(docker volume ls -q -f 'name=docker-migrid*');\
    fi


Secondly, when the repository directory is cleaned and ready for a fresh build, the Makefile will subsequently execute the `init` target, which initializes the `docker-migrid` directory.
Specifically, it will create the required directories, both for the build and the runtime itself. These required directories includes the `certs`, `httpd`, `mig`, and `state` directories.

- certs
    The `certs` directory will be populated by the MiGrid container with the generated security certificates that was generated by the build.
    In general there should be no reason to touch these after it has been created.

- httpd
    The `httpd` directory contains the state and configuration files for the Apache webserver that is run by the MiGrid service.

- mig
    The `mig` directory contains the actual MiG source code directory, as if had been cloned from the original MiG repository.

- state
    The `state` directory, contains MiG state directories, which are the directories MiG uses to populate state related data, such as users home directories, logs and the likes.

All of these directories will be populated by the container when the Docker MiGrid service is deployed.
The result therefore of executing the `init` Makefile target can be seen below::

    $:docker-migrid username$ make init
    mkdir -p certs
    mkdir -p httpd
    mkdir -p mig
    mkdir -p state

Finally, once the repository directory has been initialize, the Docker MiGrid image is ready to be built.
This is achived with the `build` target inside the Makefile. By executing this, the image build process will comence, an example of this can be seen below::

    docker-compose build
    WARNING: Python-dotenv could not parse statement starting at line 5
    devdns uses an image, skipping
    nginx-proxy uses an image, skipping
    Building migrid
    [+] Building 38.6s (13/75)
    ...


After this is complete, you should now be ready to deploy the MiGrid service with Docker.
